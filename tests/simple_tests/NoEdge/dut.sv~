module dut(clk, fifo_push, fullness_in);
   parameter               DEPTH      = 4;
   parameter               DEPTH_BITS = 2; //0 is ilegal
   input                      clk;
   input wire               fifo_push;
   
   output reg [DEPTH-1:0]           fullness_in;
   reg [DEPTH_BITS-1:0]       ptr_in;
   
   always @(/*AUTOSENSE*/fifo_push or ptr_in)
   //always @*
     begin
    fullness_in = 4'b0;
    fullness_in[ptr_in] = fifo_push;
     end
 
endmodule



/*
module temp

#(parameter size=4, logsize=2)
(
input [logsize-1:0] p_enc,
output wire [size-1:0] y
);

reg [logsize-1:0] x;
reg [2**logsize -1:0] y1;
integer pow2;
reg tmp;
integer i;
integer j;

always@*
begin
x = p_enc;
pow2 = 1;
y1[0] = 0;

for(i=0; i<logsize; i=i+1) begin
  for(j=0; j<pow2; j=j+1) begin
    tmp = y1[j];
    y1[j] = tmp | x[i];
    y1[j+pow2] = tmp & x[i];      
  end 
  pow2 = pow2+pow2;
end
end
assign y = y1[size-1:0];

endmodule
*/