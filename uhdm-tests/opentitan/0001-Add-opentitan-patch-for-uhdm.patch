diff --git a/hw/ip/alert_handler/rtl/alert_handler.sv b/hw/ip/alert_handler/rtl/alert_handler.sv
index 65035ad0b..001825885 100644
--- a/hw/ip/alert_handler/rtl/alert_handler.sv
+++ b/hw/ip/alert_handler/rtl/alert_handler.sv
@@ -43,7 +43,7 @@ module alert_handler
 
   logic [N_CLASSES-1:0] irq;
   hw2reg_wrap_t hw2reg_wrap;
-  reg2hw_wrap_t reg2hw_wrap;
+  wire [811:0] reg2hw_wrap;
 
   // TODO: make this fully parametric at some point
   assign {intr_classd_o,
@@ -79,9 +79,9 @@ module alert_handler
     .entropy_i,
     // we enable ping testing as soon as the config
     // regs have been locked
-    .en_i               ( reg2hw_wrap.config_locked    ),
-    .alert_en_i         ( reg2hw_wrap.alert_en         ),
-    .ping_timeout_cyc_i ( reg2hw_wrap.ping_timeout_cyc ),
+    .en_i(reg2hw_wrap[811]),
+    .alert_en_i(reg2hw_wrap[774-:5]),
+    .ping_timeout_cyc_i(reg2hw_wrap[810-:24]),
     // this determines the range of the randomly generated
     // wait period between ping. maximum mask width is PING_CNT_DW.
     .wait_cyc_mask_i    ( PING_CNT_DW'(24'hFFFFFF)     ),
@@ -116,7 +116,7 @@ module alert_handler
     );
   end
 
-  assign loc_alert_trig[2] = |(reg2hw_wrap.alert_en & alert_integfail);
+  assign loc_alert_trig[2] = |(reg2hw_wrap[774-:5] & alert_integfail);
 
   ///////////////////////////////////////
   // Set alert cause bits and classify //
@@ -125,10 +125,10 @@ module alert_handler
   alert_handler_class i_class (
     .alert_trig_i      ( alert_trig                  ),
     .loc_alert_trig_i  ( loc_alert_trig              ),
-    .alert_en_i        ( reg2hw_wrap.alert_en        ),
-    .loc_alert_en_i    ( reg2hw_wrap.loc_alert_en    ),
-    .alert_class_i     ( reg2hw_wrap.alert_class     ),
-    .loc_alert_class_i ( reg2hw_wrap.loc_alert_class ),
+    .alert_en_i(reg2hw_wrap[774-:5]),
+    .loc_alert_en_i(reg2hw_wrap[786-:4]),
+    .alert_class_i(reg2hw_wrap[769-:10]),
+    .loc_alert_class_i(reg2hw_wrap[782-:8]),
     .alert_cause_o     ( hw2reg_wrap.alert_cause     ),
     .loc_alert_cause_o ( hw2reg_wrap.loc_alert_cause ),
     .class_trig_o      ( hw2reg_wrap.class_trig      )
@@ -145,10 +145,10 @@ module alert_handler
     alert_handler_accu i_accu (
       .clk_i,
       .rst_ni,
-      .class_en_i   ( reg2hw_wrap.class_en[k]           ),
-      .clr_i        ( reg2hw_wrap.class_clr[k]          ),
+      .class_en_i(reg2hw_wrap[756 + k]),
+      .clr_i(reg2hw_wrap[752 + k]),
       .class_trig_i ( hw2reg_wrap.class_trig[k]         ),
-      .thresh_i     ( reg2hw_wrap.class_accum_thresh[k] ),
+      .thresh_i(reg2hw_wrap[688 + (k * AccuCntDw)+:AccuCntDw]),
       .accu_cnt_o   ( hw2reg_wrap.class_accum_cnt[k]    ),
       .accu_trig_o  ( class_accum_trig[k]               )
     );
@@ -156,16 +156,16 @@ module alert_handler
     alert_handler_esc_timer i_esc_timer (
       .clk_i,
       .rst_ni,
-      .en_i             ( reg2hw_wrap.class_en[k]          ),
+      .en_i(reg2hw_wrap[756 + k]),
       // this clear does not apply to interrupts
-      .clr_i            ( reg2hw_wrap.class_clr[k]         ),
+      .clr_i(reg2hw_wrap[752 + k]),
       // an interrupt enables the timeout
       .timeout_en_i     ( irq[k]                           ),
       .accum_trig_i     ( class_accum_trig[k]              ),
-      .timeout_cyc_i    ( reg2hw_wrap.class_timeout_cyc[k] ),
-      .esc_en_i         ( reg2hw_wrap.class_esc_en[k]      ),
-      .esc_map_i        ( reg2hw_wrap.class_esc_map[k]     ),
-      .phase_cyc_i      ( reg2hw_wrap.class_phase_cyc[k]   ),
+      .timeout_cyc_i(reg2hw_wrap[560 + (k * EscCntDw)+:EscCntDw]),
+      .esc_en_i(reg2hw_wrap[32 + (k * N_ESC_SEV)+:N_ESC_SEV]),
+      .esc_map_i(reg2hw_wrap[k]),
+      .phase_cyc_i(reg2hw_wrap[48 + k]),
       .esc_trig_o       ( hw2reg_wrap.class_esc_trig[k]    ),
       .esc_cnt_o        ( hw2reg_wrap.class_esc_cnt[k]     ),
       .esc_state_o      ( hw2reg_wrap.class_esc_state[k]   ),
diff --git a/hw/ip/alert_handler/rtl/alert_handler_reg_wrap.sv b/hw/ip/alert_handler/rtl/alert_handler_reg_wrap.sv
index f6dbddef4..0cbe62395 100644
--- a/hw/ip/alert_handler/rtl/alert_handler_reg_wrap.sv
+++ b/hw/ip/alert_handler/rtl/alert_handler_reg_wrap.sv
@@ -17,7 +17,7 @@ module alert_handler_reg_wrap import alert_pkg::*; (
   // hw2reg
   input  hw2reg_wrap_t         hw2reg_wrap,
   // reg2hw
-  output reg2hw_wrap_t         reg2hw_wrap
+  output wire [811:0] reg2hw_wrap
 );
 
 
@@ -26,8 +26,8 @@ module alert_handler_reg_wrap import alert_pkg::*; (
   //////////////////
 
   logic [N_CLASSES-1:0] class_autolock_en;
-  alert_handler_reg_pkg::alert_handler_reg2hw_t reg2hw;
-  alert_handler_reg_pkg::alert_handler_hw2reg_t hw2reg;
+  wire [844:0] reg2hw;
+  wire [237:0] hw2reg;
 
   alert_handler_reg_top u_reg (
     .clk_i,
@@ -45,53 +45,53 @@ module alert_handler_reg_wrap import alert_pkg::*; (
 
     prim_intr_hw #(
       .Width(1)
-    ) i_irq_classa (
+    ) i_irq_classa(
       .event_intr_i           ( hw2reg_wrap.class_trig[0]    ),
-      .reg2hw_intr_enable_q_i ( reg2hw.intr_enable.classa.q  ),
-      .reg2hw_intr_test_q_i   ( reg2hw.intr_test.classa.q    ),
-      .reg2hw_intr_test_qe_i  ( reg2hw.intr_test.classa.qe   ),
-      .reg2hw_intr_state_q_i  ( reg2hw.intr_state.classa.q   ),
-      .hw2reg_intr_state_de_o ( hw2reg.intr_state.classa.de  ),
-      .hw2reg_intr_state_d_o  ( hw2reg.intr_state.classa.d   ),
+      .reg2hw_intr_enable_q_i ( reg2hw[840]                  ),
+      .reg2hw_intr_test_q_i   ( reg2hw[836]                  ),
+      .reg2hw_intr_test_qe_i  ( reg2hw[835]                  ),
+      .reg2hw_intr_state_q_i  ( reg2hw[844]                  ),
+      .hw2reg_intr_state_de_o ( hw2reg[236]                  ),
+      .hw2reg_intr_state_d_o  ( hw2reg[237]                  ),
       .intr_o                 ( irq_o[0]                     )
     );
 
     prim_intr_hw #(
       .Width(1)
-    ) i_irq_classb (
+    ) i_irq_classb(
       .event_intr_i           ( hw2reg_wrap.class_trig[1]    ),
-      .reg2hw_intr_enable_q_i ( reg2hw.intr_enable.classb.q  ),
-      .reg2hw_intr_test_q_i   ( reg2hw.intr_test.classb.q    ),
-      .reg2hw_intr_test_qe_i  ( reg2hw.intr_test.classb.qe   ),
-      .reg2hw_intr_state_q_i  ( reg2hw.intr_state.classb.q   ),
-      .hw2reg_intr_state_de_o ( hw2reg.intr_state.classb.de  ),
-      .hw2reg_intr_state_d_o  ( hw2reg.intr_state.classb.d   ),
+      .reg2hw_intr_enable_q_i ( reg2hw[839]                  ),
+      .reg2hw_intr_test_q_i   ( reg2hw[834]                  ),
+      .reg2hw_intr_test_qe_i  ( reg2hw[833]                  ),
+      .reg2hw_intr_state_q_i  ( reg2hw[843]                  ),
+      .hw2reg_intr_state_de_o ( hw2reg[234]                  ),
+      .hw2reg_intr_state_d_o  ( hw2reg[235]                  ),
       .intr_o                 ( irq_o[1]                     )
     );
 
     prim_intr_hw #(
       .Width(1)
-    ) i_irq_classc (
+    ) i_irq_classc(
       .event_intr_i           ( hw2reg_wrap.class_trig[2]    ),
-      .reg2hw_intr_enable_q_i ( reg2hw.intr_enable.classc.q  ),
-      .reg2hw_intr_test_q_i   ( reg2hw.intr_test.classc.q    ),
-      .reg2hw_intr_test_qe_i  ( reg2hw.intr_test.classc.qe   ),
-      .reg2hw_intr_state_q_i  ( reg2hw.intr_state.classc.q   ),
-      .hw2reg_intr_state_de_o ( hw2reg.intr_state.classc.de  ),
-      .hw2reg_intr_state_d_o  ( hw2reg.intr_state.classc.d   ),
+      .reg2hw_intr_enable_q_i ( reg2hw[838]                  ),
+      .reg2hw_intr_test_q_i   ( reg2hw[832]                  ),
+      .reg2hw_intr_test_qe_i  ( reg2hw[831]                  ),
+      .reg2hw_intr_state_q_i  ( reg2hw[842]                  ),
+      .hw2reg_intr_state_de_o ( hw2reg[232]                  ),
+      .hw2reg_intr_state_d_o  ( hw2reg[233]                  ),
       .intr_o                 ( irq_o[2]                     )
     );
 
     prim_intr_hw #(
       .Width(1)
-    ) i_irq_classd (
+    ) i_irq_classd(
       .event_intr_i           ( hw2reg_wrap.class_trig[3]    ),
-      .reg2hw_intr_enable_q_i ( reg2hw.intr_enable.classd.q  ),
-      .reg2hw_intr_test_q_i   ( reg2hw.intr_test.classd.q    ),
-      .reg2hw_intr_test_qe_i  ( reg2hw.intr_test.classd.qe   ),
-      .reg2hw_intr_state_q_i  ( reg2hw.intr_state.classd.q   ),
-      .hw2reg_intr_state_de_o ( hw2reg.intr_state.classd.de  ),
-      .hw2reg_intr_state_d_o  ( hw2reg.intr_state.classd.d   ),
+      .reg2hw_intr_enable_q_i ( reg2hw[837]                  ),
+      .reg2hw_intr_test_q_i   ( reg2hw[830]                  ),
+      .reg2hw_intr_test_qe_i  ( reg2hw[829]                  ),
+      .reg2hw_intr_state_q_i  ( reg2hw[841]                  ),
+      .hw2reg_intr_state_de_o ( hw2reg[230]                  ),
+      .hw2reg_intr_state_d_o  ( hw2reg[231]                  ),
       .intr_o                 ( irq_o[3]                     )
     );
 
@@ -102,185 +102,80 @@ module alert_handler_reg_wrap import alert_pkg::*; (
   // if an alert is enabled and it fires,
   // we have to set the corresponding cause bit
   for (genvar k = 0; k < NAlerts; k++) begin : gen_alert_cause
-    assign hw2reg.alert_cause[k].d  = 1'b1;
-    assign hw2reg.alert_cause[k].de = reg2hw.alert_cause[k].q |
+    assign hw2reg[220 + ((k * 2) + 1)] = 1'b1;
+    assign hw2reg[220 + (k * 2)] = reg2hw[784 + k] |
                                       hw2reg_wrap.alert_cause[k];
   end
 
   // if a local alert is enabled and it fires,
   // we have to set the corresponding cause bit
   for (genvar k = 0; k < N_LOC_ALERT; k++) begin : gen_loc_alert_cause
-    assign hw2reg.loc_alert_cause[k].d  = 1'b1;
-    assign hw2reg.loc_alert_cause[k].de = reg2hw.loc_alert_cause[k].q |
+    assign hw2reg[212 + ((k * 2) + 1)] = 1'b1;
+    assign hw2reg[212 + (k * 2)] = reg2hw[768 + k] |
                                           hw2reg_wrap.loc_alert_cause[k];
   end
 
   // ping timeout in cycles
   // autolock can clear these regs automatically upon entering escalation
   // note: the class must be activated for this to occur
-  assign { hw2reg.classd_clren.d,
-           hw2reg.classc_clren.d,
-           hw2reg.classb_clren.d,
-           hw2reg.classa_clren.d } = '0;
-
-  assign { hw2reg.classd_clren.de,
-           hw2reg.classc_clren.de,
-           hw2reg.classb_clren.de,
-           hw2reg.classa_clren.de } = hw2reg_wrap.class_esc_trig    &
-                                      class_autolock_en             &
-                                      reg2hw_wrap.class_en;
+  assign { hw2reg[52],
+           hw2reg[105],
+           hw2reg[158],
+           hw2reg[211] } = '0;
+
+  assign { hw2reg[51],
+           hw2reg[104],
+           hw2reg[157],
+           hw2reg[210] } = hw2reg_wrap.class_esc_trig    &
+                           class_autolock_en             &
+                           reg2hw_wrap[759-:4];
 
   // current accumulator counts
-  assign { hw2reg.classd_accum_cnt.d,
-           hw2reg.classc_accum_cnt.d,
-           hw2reg.classb_accum_cnt.d,
-           hw2reg.classa_accum_cnt.d } = hw2reg_wrap.class_accum_cnt;
+  assign { hw2reg[209-:16],
+           hw2reg[156-:16],
+           hw2reg[103-:16],
+           hw2reg[50-:16] } = hw2reg_wrap.class_accum_cnt;
 
   // current accumulator counts
-  assign { hw2reg.classd_esc_cnt.d,
-           hw2reg.classc_esc_cnt.d,
-           hw2reg.classb_esc_cnt.d,
-           hw2reg.classa_esc_cnt.d } = hw2reg_wrap.class_esc_cnt;
+  assign { hw2reg[193-:32],
+           hw2reg[140-:32],
+           hw2reg[87-:32],
+           hw2reg[34-:32] } = hw2reg_wrap.class_esc_cnt;
 
   // current accumulator counts
-  assign { hw2reg.classd_state.d,
-           hw2reg.classc_state.d,
-           hw2reg.classb_state.d,
-           hw2reg.classa_state.d } = hw2reg_wrap.class_esc_state;
+  assign { hw2reg[161-:3],
+           hw2reg[108-:3],
+           hw2reg[55-:3],
+           hw2reg[2-:3] } = hw2reg_wrap.class_esc_state;
 
   /////////////////////
   // reg2hw mappings //
   /////////////////////
 
   // config register lock
-  assign reg2hw_wrap.config_locked = ~reg2hw.regen.q;
+  assign reg2hw_wrap[811] = ~reg2hw[828];
 
   // alert enable and class assignments
   for (genvar k = 0; k < NAlerts; k++) begin : gen_alert_en_class
-    assign reg2hw_wrap.alert_en[k]    = reg2hw.alert_en[k].q;
-    assign reg2hw_wrap.alert_class[k] = reg2hw.alert_class[k].q;
+    assign reg2hw_wrap[770 + k] = reg2hw[799 + k];
+    assign reg2hw_wrap[760 + (k * CLASS_DW)+:CLASS_DW] = reg2hw[789 + ((k * 2) + 1)-:2];
   end
 
   // local alert enable and class assignments
   for (genvar k = 0; k < N_LOC_ALERT; k++) begin : gen_loc_alert_en_class
-    assign reg2hw_wrap.loc_alert_en[k]    = reg2hw.loc_alert_en[k].q;
-    assign reg2hw_wrap.loc_alert_class[k] = reg2hw.loc_alert_class[k].q;
+    assign reg2hw_wrap[783 + k] = reg2hw[780 + k];
+    assign reg2hw_wrap[775 + (k * CLASS_DW)+:CLASS_DW] = reg2hw[772 + ((k * 2) + 1)-:2];
   end
 
-  assign reg2hw_wrap.ping_timeout_cyc = reg2hw.ping_timeout_cyc.q;
-
-  // class enable
-  // we require that at least one of the enable signals is
-  // set for a class to be enabled
-  assign reg2hw_wrap.class_en = { reg2hw.classd_ctrl.en & ( reg2hw.classd_ctrl.en_e3 |
-                                                            reg2hw.classd_ctrl.en_e2 |
-                                                            reg2hw.classd_ctrl.en_e1 |
-                                                            reg2hw.classd_ctrl.en_e0 ),
-                                  //
-                                  reg2hw.classc_ctrl.en & ( reg2hw.classc_ctrl.en_e3 |
-                                                            reg2hw.classc_ctrl.en_e2 |
-                                                            reg2hw.classc_ctrl.en_e1 |
-                                                            reg2hw.classc_ctrl.en_e0 ),
-                                  //
-                                  reg2hw.classb_ctrl.en & ( reg2hw.classb_ctrl.en_e3 |
-                                                            reg2hw.classb_ctrl.en_e2 |
-                                                            reg2hw.classb_ctrl.en_e1 |
-                                                            reg2hw.classb_ctrl.en_e0 ),
-                                  //
-                                  reg2hw.classa_ctrl.en & ( reg2hw.classa_ctrl.en_e3 |
-                                                            reg2hw.classa_ctrl.en_e2 |
-                                                            reg2hw.classa_ctrl.en_e1 |
-                                                            reg2hw.classa_ctrl.en_e0 ) };
-
-
-  // autolock enable
-  assign class_autolock_en = { reg2hw.classd_ctrl.lock,
-                               reg2hw.classc_ctrl.lock,
-                               reg2hw.classb_ctrl.lock,
-                               reg2hw.classa_ctrl.lock };
-
-  // escalation signal enable
-  assign reg2hw_wrap.class_esc_en = { reg2hw.classd_ctrl.en_e3,
-                                      reg2hw.classd_ctrl.en_e2,
-                                      reg2hw.classd_ctrl.en_e1,
-                                      reg2hw.classd_ctrl.en_e0,
-                                      //
-                                      reg2hw.classc_ctrl.en_e3,
-                                      reg2hw.classc_ctrl.en_e2,
-                                      reg2hw.classc_ctrl.en_e1,
-                                      reg2hw.classc_ctrl.en_e0,
-                                      //
-                                      reg2hw.classb_ctrl.en_e3,
-                                      reg2hw.classb_ctrl.en_e2,
-                                      reg2hw.classb_ctrl.en_e1,
-                                      reg2hw.classb_ctrl.en_e0,
-                                      //
-                                      reg2hw.classa_ctrl.en_e3,
-                                      reg2hw.classa_ctrl.en_e2,
-                                      reg2hw.classa_ctrl.en_e1,
-                                      reg2hw.classa_ctrl.en_e0 };
-
-
-  // escalation phase to escalation signal mapping
-  assign reg2hw_wrap.class_esc_map = { reg2hw.classd_ctrl.map_e3,
-                                       reg2hw.classd_ctrl.map_e2,
-                                       reg2hw.classd_ctrl.map_e1,
-                                       reg2hw.classd_ctrl.map_e0,
-                                       //
-                                       reg2hw.classc_ctrl.map_e3,
-                                       reg2hw.classc_ctrl.map_e2,
-                                       reg2hw.classc_ctrl.map_e1,
-                                       reg2hw.classc_ctrl.map_e0,
-                                       //
-                                       reg2hw.classb_ctrl.map_e3,
-                                       reg2hw.classb_ctrl.map_e2,
-                                       reg2hw.classb_ctrl.map_e1,
-                                       reg2hw.classb_ctrl.map_e0,
-                                       //
-                                       reg2hw.classa_ctrl.map_e3,
-                                       reg2hw.classa_ctrl.map_e2,
-                                       reg2hw.classa_ctrl.map_e1,
-                                       reg2hw.classa_ctrl.map_e0 };
-
-  // TODO: check whether this is correctly locked inside the regfile
-  // writing 1b1 to a class clr register clears the accumulator and
-  // escalation state if autolock is not asserted
-  assign reg2hw_wrap.class_clr = { reg2hw.classd_clr.q & reg2hw.classd_clr.qe,
-                                   reg2hw.classc_clr.q & reg2hw.classc_clr.qe,
-                                   reg2hw.classb_clr.q & reg2hw.classb_clr.qe,
-                                   reg2hw.classa_clr.q & reg2hw.classa_clr.qe };
-
-  // accumulator thresholds
-  assign reg2hw_wrap.class_accum_thresh = { reg2hw.classd_accum_thresh.q,
-                                            reg2hw.classc_accum_thresh.q,
-                                            reg2hw.classb_accum_thresh.q,
-                                            reg2hw.classa_accum_thresh.q };
-
-  // interrupt timeout lengths
-  assign reg2hw_wrap.class_timeout_cyc = { reg2hw.classd_timeout_cyc.q,
-                                           reg2hw.classc_timeout_cyc.q,
-                                           reg2hw.classb_timeout_cyc.q,
-                                           reg2hw.classa_timeout_cyc.q };
-  // escalation phase lengths
-  assign reg2hw_wrap.class_phase_cyc = { reg2hw.classd_phase3_cyc.q,
-                                         reg2hw.classd_phase2_cyc.q,
-                                         reg2hw.classd_phase1_cyc.q,
-                                         reg2hw.classd_phase0_cyc.q,
-                                         //
-                                         reg2hw.classc_phase3_cyc.q,
-                                         reg2hw.classc_phase2_cyc.q,
-                                         reg2hw.classc_phase1_cyc.q,
-                                         reg2hw.classc_phase0_cyc.q,
-                                         //
-                                         reg2hw.classb_phase3_cyc.q,
-                                         reg2hw.classb_phase2_cyc.q,
-                                         reg2hw.classb_phase1_cyc.q,
-                                         reg2hw.classb_phase0_cyc.q,
-                                         //
-                                         reg2hw.classa_phase3_cyc.q,
-                                         reg2hw.classa_phase2_cyc.q,
-                                         reg2hw.classa_phase1_cyc.q,
-                                         reg2hw.classa_phase0_cyc.q};
+  assign reg2hw_wrap[810-:24] = reg2hw[827-:24];
+  assign reg2hw_wrap[759-:4] = {reg2hw[191] & (((reg2hw[186] | reg2hw[187]) | reg2hw[188]) | reg2hw[189]), reg2hw[383] & (((reg2hw[378] | reg2hw[379]) | reg2hw[380]) | reg2hw[381]), reg2hw[575] & (((reg2hw[570] | reg2hw[571]) | reg2hw[572]) | reg2hw[573]), reg2hw[767] & (((reg2hw[762] | reg2hw[763]) | reg2hw[764]) | reg2hw[765])};
+  assign class_autolock_en = {reg2hw[190], reg2hw[382], reg2hw[574], reg2hw[766]};
+  assign reg2hw_wrap[47-:16] = {reg2hw[186], reg2hw[187], reg2hw[188], reg2hw[189], reg2hw[378], reg2hw[379], reg2hw[380], reg2hw[381], reg2hw[570], reg2hw[571], reg2hw[572], reg2hw[573], reg2hw[762], reg2hw[763], reg2hw[764], reg2hw[765]};
+  assign reg2hw_wrap[31-:32] = {reg2hw[179-:2], reg2hw[181-:2], reg2hw[183-:2], reg2hw[185-:2], reg2hw[371-:2], reg2hw[373-:2], reg2hw[375-:2], reg2hw[377-:2], reg2hw[563-:2], reg2hw[565-:2], reg2hw[567-:2], reg2hw[569-:2], reg2hw[755-:2], reg2hw[757-:2], reg2hw[759-:2], reg2hw[761-:2]};
+  assign reg2hw_wrap[755-:4] = {reg2hw[177] & reg2hw[176], reg2hw[369] & reg2hw[368], reg2hw[561] & reg2hw[560], reg2hw[753] & reg2hw[752]};
+  assign reg2hw_wrap[751-:64] = {reg2hw[175-:16], reg2hw[367-:16], reg2hw[559-:16], reg2hw[751-:16]};
+  assign reg2hw_wrap[687-:128] = {reg2hw[159-:32], reg2hw[351-:32], reg2hw[543-:32], reg2hw[735-:32]};
+  assign reg2hw_wrap[559-:512] = {reg2hw[31-:32], reg2hw[63-:32], reg2hw[95-:32], reg2hw[127-:32], reg2hw[223-:32], reg2hw[255-:32], reg2hw[287-:32], reg2hw[319-:32], reg2hw[415-:32], reg2hw[447-:32], reg2hw[479-:32], reg2hw[511-:32], reg2hw[607-:32], reg2hw[639-:32], reg2hw[671-:32], reg2hw[703-:32]};
 
   //////////////////////
   // crashdump output //
@@ -288,12 +183,12 @@ module alert_handler_reg_wrap import alert_pkg::*; (
 
   // alert cause output
   for (genvar k = 0; k < NAlerts; k++) begin : gen_alert_cause_dump
-    assign crashdump_o.alert_cause[k]  = reg2hw.alert_cause[k].q;
+    assign crashdump_o.alert_cause[k]  = reg2hw[784 + k];
   end
 
   // local alert cause register output
   for (genvar k = 0; k < N_LOC_ALERT; k++) begin : gen_loc_alert_cause_dump
-    assign crashdump_o.loc_alert_cause[k]  = reg2hw.loc_alert_cause[k].q;
+    assign crashdump_o.loc_alert_cause[k]  = reg2hw[768 + k];
   end
 
   assign crashdump_o.class_accum_cnt = hw2reg_wrap.class_accum_cnt;
diff --git a/hw/ip/alert_handler/rtl/alert_pkg.sv b/hw/ip/alert_handler/rtl/alert_pkg.sv
index 5324b4978..a1a858232 100644
--- a/hw/ip/alert_handler/rtl/alert_pkg.sv
+++ b/hw/ip/alert_handler/rtl/alert_pkg.sv
@@ -68,9 +68,9 @@ package alert_pkg;
     logic [N_CLASSES-1:0]                              class_clr;          // clears esc/accu
     logic [N_CLASSES-1:0][AccuCntDw-1:0]               class_accum_thresh; // accum esc threshold
     logic [N_CLASSES-1:0][EscCntDw-1:0]                class_timeout_cyc;  // interrupt timeout
-    logic [N_CLASSES-1:0][N_PHASES-1:0][EscCntDw-1:0]  class_phase_cyc;    // length of phases 0..3
+    logic [511:0]  class_phase_cyc;    // length of phases 0..3
     logic [N_CLASSES-1:0][N_ESC_SEV-1:0]               class_esc_en;       // esc signal enables
-    logic [N_CLASSES-1:0][N_ESC_SEV-1:0][PHASE_DW-1:0] class_esc_map;      // esc signal/phase map
+    logic [31:0] class_esc_map;      // esc signal/phase map
   } reg2hw_wrap_t;
 
 endpackage : alert_pkg
diff --git a/hw/ip/flash_ctrl/rtl/flash_ctrl.sv b/hw/ip/flash_ctrl/rtl/flash_ctrl.sv
index 6b573e1b7..6a4f5b30e 100644
--- a/hw/ip/flash_ctrl/rtl/flash_ctrl.sv
+++ b/hw/ip/flash_ctrl/rtl/flash_ctrl.sv
@@ -309,20 +309,20 @@ module flash_ctrl import flash_ctrl_pkg::*; (
   end
 
   // extra region is the default region
-  flash_ctrl_reg2hw_mp_region_cfg_mreg_t [MpRegions:0] region_cfgs;
+  logic [MpRegions*24:0] region_cfgs;
 
-  assign region_cfgs[MpRegions-1:0] = reg2hw.mp_region_cfg[MpRegions-1:0];
+  assign region_cfgs[(MpRegions - 1)*24-1:0] = reg2hw.mp_region_cfg[MpRegions*24-1:0];
 
   //default region
-  assign region_cfgs[MpRegions].base.q = '0;
-  assign region_cfgs[MpRegions].size.q = NumBanks * PagesPerBank;
-  assign region_cfgs[MpRegions].en.q = 1'b1;
-  assign region_cfgs[MpRegions].rd_en.q = reg2hw.default_region.rd_en.q;
-  assign region_cfgs[MpRegions].prog_en.q = reg2hw.default_region.prog_en.q;
-  assign region_cfgs[MpRegions].erase_en.q = reg2hw.default_region.erase_en.q;
+  assign region_cfgs[(MpRegions - 1)*24+19:(MpRegions - 1)*24+11] = '0;
+  assign region_cfgs[(MpRegions - 1)*24+10:(MpRegions - 1)*24+1] = NumBanks * PagesPerBank;
+  assign region_cfgs[(MpRegions - 1)*24+23] = 1'b1;
+  assign region_cfgs[(MpRegions - 1)*24+22] = reg2hw.default_region.rd_en.q;
+  assign region_cfgs[(MpRegions - 1)*24+21] = reg2hw.default_region.prog_en.q;
+  assign region_cfgs[(MpRegions - 1)*24+20] = reg2hw.default_region.erase_en.q;
   // we are allowed to set default accessibility of data partitions
   // however info partitions default to inaccessible
-  assign region_cfgs[MpRegions].partition.q = FlashPartData;
+  assign region_cfgs[(MpRegions - 1)*24+0] = FlashPartData;
 
   flash_part_e flash_part_sel;
   assign flash_part_sel = flash_part_e'(reg2hw.control.partition_sel.q);
diff --git a/hw/ip/flash_ctrl/rtl/flash_ctrl_reg_pkg.sv b/hw/ip/flash_ctrl/rtl/flash_ctrl_reg_pkg.sv
index 4c7081ef9..6e318128d 100644
--- a/hw/ip/flash_ctrl/rtl/flash_ctrl_reg_pkg.sv
+++ b/hw/ip/flash_ctrl/rtl/flash_ctrl_reg_pkg.sv
@@ -250,9 +250,9 @@ package flash_ctrl_reg_pkg;
     flash_ctrl_reg2hw_control_reg_t control; // [289:273]
     flash_ctrl_reg2hw_addr_reg_t addr; // [272:241]
     flash_ctrl_reg2hw_scramble_en_reg_t scramble_en; // [240:240]
-    flash_ctrl_reg2hw_mp_region_cfg_mreg_t [7:0] mp_region_cfg; // [239:48]
+    logic [191:0] mp_region_cfg; // [239:48]
     flash_ctrl_reg2hw_default_region_reg_t default_region; // [47:45]
-    flash_ctrl_reg2hw_mp_bank_cfg_mreg_t [1:0] mp_bank_cfg; // [44:43]
+    logic [1:0] mp_bank_cfg; // [44:43]
     flash_ctrl_reg2hw_scratch_reg_t scratch; // [42:11]
     flash_ctrl_reg2hw_fifo_lvl_reg_t fifo_lvl; // [10:1]
     flash_ctrl_reg2hw_fifo_rst_reg_t fifo_rst; // [0:0]
diff --git a/hw/ip/flash_ctrl/rtl/flash_ctrl_reg_top.sv b/hw/ip/flash_ctrl/rtl/flash_ctrl_reg_top.sv
index 07945937c..518462c7d 100644
--- a/hw/ip/flash_ctrl/rtl/flash_ctrl_reg_top.sv
+++ b/hw/ip/flash_ctrl/rtl/flash_ctrl_reg_top.sv
@@ -1075,7 +1075,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[0].en.q ),
+    .q      (reg2hw.mp_region_cfg[0*24+23] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg0_en0_qs)
@@ -1101,7 +1101,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[0].rd_en.q ),
+    .q      (reg2hw.mp_region_cfg[0*24+22] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg0_rd_en0_qs)
@@ -1127,7 +1127,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[0].prog_en.q ),
+    .q      (reg2hw.mp_region_cfg[0*24+21] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg0_prog_en0_qs)
@@ -1153,7 +1153,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[0].erase_en.q ),
+    .q      (reg2hw.mp_region_cfg[0*24+20] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg0_erase_en0_qs)
@@ -1179,7 +1179,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[0].base.q ),
+    .q      (reg2hw.mp_region_cfg[0*24+19:0*24+11] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg0_base0_qs)
@@ -1205,7 +1205,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[0].size.q ),
+    .q      (reg2hw.mp_region_cfg[0*24+10:0*24+1] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg0_size0_qs)
@@ -1231,7 +1231,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[0].partition.q ),
+    .q      (reg2hw.mp_region_cfg[0*24+0] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg0_partition0_qs)
@@ -1260,7 +1260,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[1].en.q ),
+    .q      (reg2hw.mp_region_cfg[1*24+23] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg1_en1_qs)
@@ -1286,7 +1286,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[1].rd_en.q ),
+    .q      (reg2hw.mp_region_cfg[1*24+22] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg1_rd_en1_qs)
@@ -1312,7 +1312,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[1].prog_en.q ),
+    .q      (reg2hw.mp_region_cfg[1*24+21] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg1_prog_en1_qs)
@@ -1338,7 +1338,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[1].erase_en.q ),
+    .q      (reg2hw.mp_region_cfg[1*24+20] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg1_erase_en1_qs)
@@ -1364,7 +1364,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[1].base.q ),
+    .q      (reg2hw.mp_region_cfg[1*24+19:1*24+11] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg1_base1_qs)
@@ -1390,7 +1390,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[1].size.q ),
+    .q      (reg2hw.mp_region_cfg[1*24+10:1*24+1] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg1_size1_qs)
@@ -1416,7 +1416,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[1].partition.q ),
+    .q      (reg2hw.mp_region_cfg[1*24+0] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg1_partition1_qs)
@@ -1445,7 +1445,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[2].en.q ),
+    .q      (reg2hw.mp_region_cfg[2*24+23] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg2_en2_qs)
@@ -1471,7 +1471,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[2].rd_en.q ),
+    .q      (reg2hw.mp_region_cfg[2*24+22] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg2_rd_en2_qs)
@@ -1497,7 +1497,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[2].prog_en.q ),
+    .q      (reg2hw.mp_region_cfg[2*24+21] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg2_prog_en2_qs)
@@ -1523,7 +1523,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[2].erase_en.q ),
+    .q      (reg2hw.mp_region_cfg[2*24+20] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg2_erase_en2_qs)
@@ -1549,7 +1549,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[2].base.q ),
+    .q      (reg2hw.mp_region_cfg[2*24+19:2*24+11] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg2_base2_qs)
@@ -1575,7 +1575,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[2].size.q ),
+    .q      (reg2hw.mp_region_cfg[2*24+10:2*24+1] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg2_size2_qs)
@@ -1601,7 +1601,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[2].partition.q ),
+    .q      (reg2hw.mp_region_cfg[2*24+0] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg2_partition2_qs)
@@ -1630,7 +1630,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[3].en.q ),
+    .q      (reg2hw.mp_region_cfg[3*24+23] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg3_en3_qs)
@@ -1656,7 +1656,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[3].rd_en.q ),
+    .q      (reg2hw.mp_region_cfg[3*24+22] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg3_rd_en3_qs)
@@ -1682,7 +1682,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[3].prog_en.q ),
+    .q      (reg2hw.mp_region_cfg[3*24+21] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg3_prog_en3_qs)
@@ -1708,7 +1708,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[3].erase_en.q ),
+    .q      (reg2hw.mp_region_cfg[3*24+20] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg3_erase_en3_qs)
@@ -1734,7 +1734,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[3].base.q ),
+    .q      (reg2hw.mp_region_cfg[3*24+19:3*24+11] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg3_base3_qs)
@@ -1760,7 +1760,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[3].size.q ),
+    .q      (reg2hw.mp_region_cfg[3*24+10:3*24+1] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg3_size3_qs)
@@ -1786,7 +1786,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[3].partition.q ),
+    .q      (reg2hw.mp_region_cfg[3*24+0] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg3_partition3_qs)
@@ -1815,7 +1815,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[4].en.q ),
+    .q      (reg2hw.mp_region_cfg[4*24+23] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg4_en4_qs)
@@ -1841,7 +1841,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[4].rd_en.q ),
+    .q      (reg2hw.mp_region_cfg[4*24+22] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg4_rd_en4_qs)
@@ -1867,7 +1867,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[4].prog_en.q ),
+    .q      (reg2hw.mp_region_cfg[4*24+21] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg4_prog_en4_qs)
@@ -1893,7 +1893,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[4].erase_en.q ),
+    .q      (reg2hw.mp_region_cfg[4*24+20] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg4_erase_en4_qs)
@@ -1919,7 +1919,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[4].base.q ),
+    .q      (reg2hw.mp_region_cfg[4*24+19:4*24+11] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg4_base4_qs)
@@ -1945,7 +1945,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[4].size.q ),
+    .q      (reg2hw.mp_region_cfg[4*24+10:4*24+1] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg4_size4_qs)
@@ -1971,7 +1971,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[4].partition.q ),
+    .q      (reg2hw.mp_region_cfg[4*24+0] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg4_partition4_qs)
@@ -2000,7 +2000,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[5].en.q ),
+    .q      (reg2hw.mp_region_cfg[5*24+23] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg5_en5_qs)
@@ -2026,7 +2026,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[5].rd_en.q ),
+    .q      (reg2hw.mp_region_cfg[5*24+22] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg5_rd_en5_qs)
@@ -2052,7 +2052,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[5].prog_en.q ),
+    .q      (reg2hw.mp_region_cfg[5*24+21] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg5_prog_en5_qs)
@@ -2078,7 +2078,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[5].erase_en.q ),
+    .q      (reg2hw.mp_region_cfg[5*24+20] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg5_erase_en5_qs)
@@ -2104,7 +2104,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[5].base.q ),
+    .q      (reg2hw.mp_region_cfg[5*24+19:5*24+11] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg5_base5_qs)
@@ -2130,7 +2130,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[5].size.q ),
+    .q      (reg2hw.mp_region_cfg[5*24+10:5*24+1] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg5_size5_qs)
@@ -2156,7 +2156,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[5].partition.q ),
+    .q      (reg2hw.mp_region_cfg[5*24+0] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg5_partition5_qs)
@@ -2185,7 +2185,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[6].en.q ),
+    .q      (reg2hw.mp_region_cfg[6*24+23] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg6_en6_qs)
@@ -2211,7 +2211,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[6].rd_en.q ),
+    .q      (reg2hw.mp_region_cfg[6*24+22] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg6_rd_en6_qs)
@@ -2237,7 +2237,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[6].prog_en.q ),
+    .q      (reg2hw.mp_region_cfg[6*24+21] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg6_prog_en6_qs)
@@ -2263,7 +2263,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[6].erase_en.q ),
+    .q      (reg2hw.mp_region_cfg[6*24+20] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg6_erase_en6_qs)
@@ -2289,7 +2289,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[6].base.q ),
+    .q      (reg2hw.mp_region_cfg[6*24+19:6*24+11] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg6_base6_qs)
@@ -2315,7 +2315,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[6].size.q ),
+    .q      (reg2hw.mp_region_cfg[6*24+10:6*24+1] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg6_size6_qs)
@@ -2341,7 +2341,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[6].partition.q ),
+    .q      (reg2hw.mp_region_cfg[6*24+0] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg6_partition6_qs)
@@ -2370,7 +2370,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[7].en.q ),
+    .q      (reg2hw.mp_region_cfg[7*24+23] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg7_en7_qs)
@@ -2396,7 +2396,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[7].rd_en.q ),
+    .q      (reg2hw.mp_region_cfg[7*24+22] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg7_rd_en7_qs)
@@ -2422,7 +2422,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[7].prog_en.q ),
+    .q      (reg2hw.mp_region_cfg[7*24+21] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg7_prog_en7_qs)
@@ -2448,7 +2448,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[7].erase_en.q ),
+    .q      (reg2hw.mp_region_cfg[7*24+20] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg7_erase_en7_qs)
@@ -2474,7 +2474,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[7].base.q ),
+    .q      (reg2hw.mp_region_cfg[7*24+19:7*24+11] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg7_base7_qs)
@@ -2500,7 +2500,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[7].size.q ),
+    .q      (reg2hw.mp_region_cfg[7*24+10:7*24+1] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg7_size7_qs)
@@ -2526,7 +2526,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_region_cfg[7].partition.q ),
+    .q      (reg2hw.mp_region_cfg[7*24+0] ),
 
     // to register interface (read)
     .qs     (mp_region_cfg7_partition7_qs)
@@ -2664,7 +2664,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_bank_cfg[0].q ),
+    .q      (reg2hw.mp_bank_cfg[0] ),
 
     // to register interface (read)
     .qs     (mp_bank_cfg_erase_en0_qs)
@@ -2690,7 +2690,7 @@ module flash_ctrl_reg_top (
 
     // to internal hardware
     .qe     (),
-    .q      (reg2hw.mp_bank_cfg[1].q ),
+    .q      (reg2hw.mp_bank_cfg[1] ),
 
     // to register interface (read)
     .qs     (mp_bank_cfg_erase_en1_qs)
diff --git a/hw/ip/rv_timer/rtl/rv_timer.sv b/hw/ip/rv_timer/rtl/rv_timer.sv
index 9b939eedd..a4c91c238 100644
--- a/hw/ip/rv_timer/rtl/rv_timer.sv
+++ b/hw/ip/rv_timer/rtl/rv_timer.sv
@@ -31,10 +31,10 @@ module rv_timer (
 
   logic [N_HARTS-1:0] tick;
 
-  logic [63:0] mtime_d  [N_HARTS];
-  logic [63:0] mtime    [N_HARTS];
-  logic [63:0] mtimecmp [N_HARTS][N_TIMERS]; // Only [harts][0] is connected to mtimecmp CSRs
-  logic        mtimecmp_update [N_HARTS][N_TIMERS];
+  logic [63:0] mtime_d  ;
+  logic [63:0] mtime    ;
+  logic [63:0] mtimecmp; // Only [harts][0] is connected to mtimecmp CSRs
+  logic        mtimecmp_update;
 
   logic [N_HARTS*N_TIMERS-1:0] intr_timer_set;
   logic [N_HARTS*N_TIMERS-1:0] intr_timer_en;
@@ -52,25 +52,25 @@ module rv_timer (
 
   // Once reggen supports nested multireg, the following can be automated. For the moment, it must
   // be connected manually.
-  assign active[0]  = reg2hw.ctrl[0].q;
+  assign active[0]  = reg2hw.ctrl.q;
   assign prescaler = '{reg2hw.cfg0.prescale.q};
   assign step      = '{reg2hw.cfg0.step.q};
 
   assign hw2reg.timer_v_upper0.de = tick[0];
   assign hw2reg.timer_v_lower0.de = tick[0];
-  assign hw2reg.timer_v_upper0.d = mtime_d[0][63:32];
-  assign hw2reg.timer_v_lower0.d = mtime_d[0][31: 0];
-  assign mtime[0] = {reg2hw.timer_v_upper0.q, reg2hw.timer_v_lower0.q};
+  assign hw2reg.timer_v_upper0.d = mtime_d[63:32];
+  assign hw2reg.timer_v_lower0.d = mtime_d[31: 0];
+  assign mtime = {reg2hw.timer_v_upper0.q, reg2hw.timer_v_lower0.q};
   assign mtimecmp = '{'{{reg2hw.compare_upper0_0.q,reg2hw.compare_lower0_0.q}}};
-  assign mtimecmp_update[0][0] = reg2hw.compare_upper0_0.qe | reg2hw.compare_lower0_0.qe;
+  assign mtimecmp_update = reg2hw.compare_upper0_0.qe | reg2hw.compare_lower0_0.qe;
 
   assign intr_timer_expired_0_0_o = intr_out[0];
-  assign intr_timer_en            = reg2hw.intr_enable0[0].q;
-  assign intr_timer_state_q       = reg2hw.intr_state0[0].q;
-  assign intr_timer_test_q        = reg2hw.intr_test0[0].q;
-  assign intr_timer_test_qe       = reg2hw.intr_test0[0].qe;
-  assign hw2reg.intr_state0[0].de = intr_timer_state_de | mtimecmp_update[0][0];
-  assign hw2reg.intr_state0[0].d  = intr_timer_state_d & ~mtimecmp_update[0][0];
+  assign intr_timer_en            = reg2hw.intr_enable0.q;
+  assign intr_timer_state_q       = reg2hw.intr_state0.q;
+  assign intr_timer_test_q        = reg2hw.intr_test0.q;
+  assign intr_timer_test_qe       = reg2hw.intr_test0.qe;
+  assign hw2reg.intr_state0.de = intr_timer_state_de | mtimecmp_update;
+  assign hw2reg.intr_state0.d  = intr_timer_state_d & ~mtimecmp_update;
 
 
   for (genvar h = 0 ; h < N_HARTS ; h++) begin : gen_harts
@@ -96,14 +96,14 @@ module rv_timer (
       .rst_ni,
 
       .active    (active[h]),
-      .prescaler (prescaler[h]),
-      .step      (step[h]),
+      .prescaler (prescaler),
+      .step      (step),
 
       .tick      (tick[h]),
 
-      .mtime_d   (mtime_d[h]),
-      .mtime     (mtime[h]),
-      .mtimecmp  (mtimecmp[h]),
+      .mtime_d   (mtime_d),
+      .mtime     (mtime),
+      .mtimecmp  (mtimecmp),
 
       .intr      (intr_timer_set[h*N_TIMERS+:N_TIMERS])
     );
diff --git a/hw/ip/rv_timer/rtl/rv_timer_reg_pkg.sv b/hw/ip/rv_timer/rtl/rv_timer_reg_pkg.sv
index 2addad698..37e6d79c4 100644
--- a/hw/ip/rv_timer/rtl/rv_timer_reg_pkg.sv
+++ b/hw/ip/rv_timer/rtl/rv_timer_reg_pkg.sv
@@ -78,15 +78,15 @@ package rv_timer_reg_pkg;
   // Register to internal design logic //
   ///////////////////////////////////////
   typedef struct packed {
-    rv_timer_reg2hw_ctrl_mreg_t [0:0] ctrl; // [154:154]
+    rv_timer_reg2hw_ctrl_mreg_t ctrl; // [154:154]
     rv_timer_reg2hw_cfg0_reg_t cfg0; // [153:134]
     rv_timer_reg2hw_timer_v_lower0_reg_t timer_v_lower0; // [133:102]
     rv_timer_reg2hw_timer_v_upper0_reg_t timer_v_upper0; // [101:70]
     rv_timer_reg2hw_compare_lower0_0_reg_t compare_lower0_0; // [69:37]
     rv_timer_reg2hw_compare_upper0_0_reg_t compare_upper0_0; // [36:4]
-    rv_timer_reg2hw_intr_enable0_mreg_t [0:0] intr_enable0; // [3:3]
-    rv_timer_reg2hw_intr_state0_mreg_t [0:0] intr_state0; // [2:2]
-    rv_timer_reg2hw_intr_test0_mreg_t [0:0] intr_test0; // [1:0]
+    rv_timer_reg2hw_intr_enable0_mreg_t intr_enable0; // [3:3]
+    rv_timer_reg2hw_intr_state0_mreg_t intr_state0; // [2:2]
+    rv_timer_reg2hw_intr_test0_mreg_t intr_test0; // [1:0]
   } rv_timer_reg2hw_t;
 
   ///////////////////////////////////////
@@ -95,7 +95,7 @@ package rv_timer_reg_pkg;
   typedef struct packed {
     rv_timer_hw2reg_timer_v_lower0_reg_t timer_v_lower0; // [67:36]
     rv_timer_hw2reg_timer_v_upper0_reg_t timer_v_upper0; // [35:4]
-    rv_timer_hw2reg_intr_state0_mreg_t [0:0] intr_state0; // [3:2]
+    rv_timer_hw2reg_intr_state0_mreg_t intr_state0; // [3:2]
   } rv_timer_hw2reg_t;
 
   // Register Address
diff --git a/hw/ip/tlul/rtl/tlul_adapter_sram.sv b/hw/ip/tlul/rtl/tlul_adapter_sram.sv
index 6e2f33191..2820baadd 100644
--- a/hw/ip/tlul/rtl/tlul_adapter_sram.sv
+++ b/hw/ip/tlul/rtl/tlul_adapter_sram.sv
@@ -134,20 +134,17 @@ module tlul_adapter_sram #(
     end
   end
 
-  assign tl_o = '{
-      d_valid  : d_valid ,
-      d_opcode : (d_valid && reqfifo_rdata.op != OpRead) ? AccessAck : AccessAckData,
-      d_param  : '0,
-      d_size   : (d_valid) ? reqfifo_rdata.size : '0,
-      d_source : (d_valid) ? reqfifo_rdata.source : '0,
-      d_sink   : 1'b0,
-      d_data   : (d_valid && rspfifo_rvalid && reqfifo_rdata.op == OpRead)
-                 ? rspfifo_rdata.data : '0,
-      d_user   : '0,
-      d_error  : d_valid && d_error,
-
-      a_ready  : (gnt_i | error_internal) & reqfifo_wready & sramreqfifo_wready
-  };
+  assign tl_o.d_valid   = d_valid;
+  assign tl_o.d_opcode  = (d_valid && reqfifo_rdata.op != OpRead) ? AccessAck : AccessAckData;
+  assign tl_o.d_param   = '0;
+  assign tl_o.d_size    = (d_valid) ? reqfifo_rdata.size : '0;
+  assign tl_o.d_source  = (d_valid) ? reqfifo_rdata.source : '0;
+  assign tl_o.d_sink    = 1'b0;
+  assign tl_o.d_data    = (d_valid && rspfifo_rvalid && reqfifo_rdata.op == OpRead) ? rspfifo_rdata.data : '0;
+  assign tl_o.d_user    = '0;
+  assign tl_o.d_error   = d_valid && d_error;
+
+  assign tl_o.a_ready   = (gnt_i | error_internal) & reqfifo_wready & sramreqfifo_wready;
 
   // a_ready depends on the FIFO full condition and grant from SRAM (or SRAM arbiter)
   // assemble response, including read response, write response, and error for unsupported stuff
@@ -171,8 +168,8 @@ module tlul_adapter_sram #(
   end
 
   // Convert byte mask to SRAM bit mask for writes, and only forward valid data
-  logic [WidthMult-1:0][top_pkg::TL_DW-1:0] wmask_int;
-  logic [WidthMult-1:0][top_pkg::TL_DW-1:0] wdata_int;
+  logic [(WidthMult * top_pkg::TL_DW) - 1:0] wmask_int;
+  logic [(WidthMult * top_pkg::TL_DW) - 1:0] wdata_int;
 
   always_comb begin
     wmask_int = '0;
@@ -180,8 +177,8 @@ module tlul_adapter_sram #(
 
     if (tl_i.a_valid) begin
       for (int i = 0 ; i < top_pkg::TL_DW/8 ; i++) begin
-        wmask_int[woffset][8*i +: 8] = {8{tl_i.a_mask[i]}};
-        wdata_int[woffset][8*i +: 8] = (tl_i.a_mask[i] && we_o) ? tl_i.a_data[8*i+:8] : '0;
+        wmask_int[(woffset * top_pkg::TL_DW) + (8 * i) +: 8] = {8{tl_i.a_mask[i]}};
+        wdata_int[(woffset * top_pkg::TL_DW) + (8 * i) +: 8] = (tl_i.a_mask[i] && we_o) ? tl_i.a_data[8*i+:8] : '0;
       end
     end
   end
@@ -221,19 +218,15 @@ module tlul_adapter_sram #(
   // End: Request Error Detection
 
   assign reqfifo_wvalid = a_ack ; // Push to FIFO only when granted
-  assign reqfifo_wdata  = '{
-    op:     (tl_i.a_opcode != Get) ? OpWrite : OpRead, // To return AccessAck for opcode error
-    error:  error_internal,
-    size:   tl_i.a_size,
-    source: tl_i.a_source
-  }; // Store the request only. Doesn't have to store data
+  assign reqfifo_wdata.op      = (tl_i.a_opcode != Get) ? OpWrite : OpRead; // To return AccessAck for opcode error
+  assign reqfifo_wdata.error   = error_internal;
+  assign reqfifo_wdata.size    = tl_i.a_size;
+  assign reqfifo_wdata.source  = tl_i.a_source;
   assign reqfifo_rready = d_ack ;
 
   // push together with ReqFIFO, pop upon returning read
-  assign sramreqfifo_wdata = '{
-    mask    : tl_i.a_mask,
-    woffset : woffset
-  };
+  assign sramreqfifo_wdata.mask     = tl_i.a_mask;
+  assign sramreqfifo_wdata.woffset  = woffset;
   assign sramreqfifo_wvalid = sram_ack & ~we_o;
   assign sramreqfifo_rready = rspfifo_wvalid;
 
@@ -241,26 +234,23 @@ module tlul_adapter_sram #(
 
   // Make sure only requested bytes are forwarded
   logic [SramDw-1:0] rdata;
-  logic [WidthMult-1:0][top_pkg::TL_DW-1:0] rmask;
+  logic [(WidthMult * top_pkg::TL_DW) - 1:0] rmask;
   //logic [SramDw-1:0] rmask;
   logic [top_pkg::TL_DW-1:0] rdata_tlword;
 
   always_comb begin
     rmask = '0;
     for (int i = 0 ; i < top_pkg::TL_DW/8 ; i++) begin
-      rmask[sramreqfifo_rdata.woffset][8*i +: 8] = {8{sramreqfifo_rdata.mask[i]}};
+      rmask[(sramreqfifo_rdata.woffset * top_pkg::TL_DW) + (8 * i) +: 8] = {8{sramreqfifo_rdata.mask[i]}};
     end
   end
 
   assign rdata = rdata_i & rmask;
   assign rdata_tlword = rdata[sramreqfifo_rdata.woffset * top_pkg::TL_DW +: top_pkg::TL_DW];
 
-  assign rspfifo_wdata  = '{
-    data : rdata_tlword,
-    error: rerror_i[1] // Only care for Uncorrectable error
-  };
-  assign rspfifo_rready = (reqfifo_rdata.op == OpRead & ~reqfifo_rdata.error)
-                        ? reqfifo_rready : 1'b0 ;
+  assign rspfifo_wdata.data   = rdata_tlword;
+  assign rspfifo_wdata.error  = rerror_i[1]; // Only care for Uncorrectable error
+  assign rspfifo_rready = (reqfifo_rdata.op == OpRead & ~reqfifo_rdata.error) ? reqfifo_rready : 1'b0 ;
 
   // FIFO instance: REQ, RSP
 
diff --git a/hw/ip/tlul/rtl/tlul_socket_m1.sv b/hw/ip/tlul/rtl/tlul_socket_m1.sv
index 8637ad221..a3c29e293 100644
--- a/hw/ip/tlul/rtl/tlul_socket_m1.sv
+++ b/hw/ip/tlul/rtl/tlul_socket_m1.sv
@@ -105,18 +105,16 @@ module tlul_socket_m1 #(
     assign unused_tl_h_source = tl_h_i[i].a_source[IDW-1 -: STIDW];
 
     // Put shifted ID
-    assign hreq_fifo_i = '{
-      a_valid:    tl_h_i[i].a_valid,
-      a_opcode:   tl_h_i[i].a_opcode,
-      a_param:    tl_h_i[i].a_param,
-      a_size:     tl_h_i[i].a_size,
-      a_source:   shifted_id,
-      a_address:  tl_h_i[i].a_address,
-      a_mask:     tl_h_i[i].a_mask,
-      a_data:     tl_h_i[i].a_data,
-      a_user:     tl_h_i[i].a_user,
-      d_ready:    tl_h_i[i].d_ready
-    };
+    assign hreq_fifo_i.a_valid = tl_h_i[i].a_valid;
+    assign hreq_fifo_i.a_opcode = tl_h_i[i].a_opcode;
+    assign hreq_fifo_i.a_param = tl_h_i[i].a_param;
+    assign hreq_fifo_i.a_size = tl_h_i[i].a_size;
+    assign hreq_fifo_i.a_source = shifted_id;
+    assign hreq_fifo_i.a_address = tl_h_i[i].a_address;
+    assign hreq_fifo_i.a_mask = tl_h_i[i].a_mask;
+    assign hreq_fifo_i.a_data = tl_h_i[i].a_data;
+    assign hreq_fifo_i.a_user = tl_h_i[i].a_user;
+    assign hreq_fifo_i.d_ready = tl_h_i[i].d_ready;
 
     tlul_fifo_sync #(
       .ReqPass    (HReqPass[i]),
@@ -237,18 +235,16 @@ module tlul_socket_m1 #(
                                (drsp_fifo_o.d_source[0+:STIDW] == i) &
                               drsp_fifo_o.d_valid;
 
-    assign hrsp_fifo_i[i] = '{
-      d_valid:  hfifo_rspvalid[i],
-      d_opcode: drsp_fifo_o.d_opcode,
-      d_param:  drsp_fifo_o.d_param,
-      d_size:   drsp_fifo_o.d_size,
-      d_source: hfifo_rspid,
-      d_sink:   drsp_fifo_o.d_sink,
-      d_data:   drsp_fifo_o.d_data,
-      d_user:   drsp_fifo_o.d_user,
-      d_error:  drsp_fifo_o.d_error,
-      a_ready:  hgrant[i]
-    };
+    assign hrsp_fifo_i[i].d_valid = hfifo_rspvalid[i];
+    assign hrsp_fifo_i[i].d_opcode = drsp_fifo_o.d_opcode;
+    assign hrsp_fifo_i[i].d_param = drsp_fifo_o.d_param;
+    assign hrsp_fifo_i[i].d_size = drsp_fifo_o.d_size;
+    assign hrsp_fifo_i[i].d_source = hfifo_rspid;
+    assign hrsp_fifo_i[i].d_sink = drsp_fifo_o.d_sink;
+    assign hrsp_fifo_i[i].d_data = drsp_fifo_o.d_data;
+    assign hrsp_fifo_i[i].d_user = drsp_fifo_o.d_user;
+    assign hrsp_fifo_i[i].d_error = drsp_fifo_o.d_error;
+    assign hrsp_fifo_i[i].a_ready = hgrant[i];
   end
 
   // this assertion fails when rspid[0+:STIDW] not in [0..M-1]
diff --git a/hw/top_earlgrey/rtl/autogen/top_earlgrey.sv b/hw/top_earlgrey/rtl/autogen/top_earlgrey.sv
index 2acc14e86..c6aa89066 100644
--- a/hw/top_earlgrey/rtl/autogen/top_earlgrey.sv
+++ b/hw/top_earlgrey/rtl/autogen/top_earlgrey.sv
@@ -239,8 +239,8 @@ module top_earlgrey #(
   assign unused_irq_id = irq_id;
 
   // Alert list
-  prim_alert_pkg::alert_tx_t [alert_pkg::NAlerts-1:0]  alert_tx;
-  prim_alert_pkg::alert_rx_t [alert_pkg::NAlerts-1:0]  alert_rx;
+  wire [9:0] alert_tx;
+  wire [19:0] alert_rx;
   // Escalation outputs
   prim_esc_pkg::esc_tx_t [alert_pkg::N_ESC_SEV-1:0]  esc_tx;
   prim_esc_pkg::esc_rx_t [alert_pkg::N_ESC_SEV-1:0]  esc_rx;
@@ -259,12 +259,12 @@ module top_earlgrey #(
   pwrmgr_pkg::pwr_cpu_t       pwrmgr_pwr_cpu;
   clkmgr_pkg::clkmgr_out_t       clkmgr_clocks;
   logic       aes_idle;
-  clkmgr_pkg::clk_hint_status_t       clkmgr_status;
+  reg [2:0] clkmgr_status;
 
   always_comb begin
     // TODO: So far just aes is connected
-    clkmgr_status.idle    = clkmgr_pkg::CLK_HINT_STATUS_DEFAULT;
-    clkmgr_status.idle[0] = aes_idle;
+    clkmgr_status[2-:3] = clkmgr_pkg::CLK_HINT_STATUS_DEFAULT;
+    clkmgr_status[0] = aes_idle;
   end
 
   // Non-debug module reset == reset for everything except for the debug module
@@ -627,7 +627,7 @@ module top_earlgrey #(
       // Inter-module signals
       .flash_o(flash_ctrl_flash_req),
       .flash_i(flash_ctrl_flash_rsp),
-      .otp_i(flash_ctrl_pkg::OTP_FLASH_DEFAULT),
+      .otp_i(256'hdeadbeefbeeffacedeadbeef5a5aa5a5deadbeef5a5aa5a5deadbeefbeefface),
       .clk_i (clkmgr_clocks.clk_main_infra),
       .rst_ni (rstmgr_resets.rst_lc_n)
   );
@@ -647,8 +647,8 @@ module top_earlgrey #(
       .tl_o (tl_aes_d_d2h),
 
       // [0]: ctrl_err
-      .alert_tx_o  ( alert_tx[0:0] ),
-      .alert_rx_i  ( alert_rx[0:0] ),
+      .alert_tx_o  ( alert_tx[0+:2] ),
+      .alert_rx_i  ( alert_rx[0+:4] ),
 
       // Inter-module signals
       .idle_o(aes_idle),
@@ -666,8 +666,8 @@ module top_earlgrey #(
       .intr_hmac_err_o   (intr_hmac_hmac_err),
 
       // [1]: msg_push_sha_disabled
-      .alert_tx_o  ( alert_tx[1:1] ),
-      .alert_rx_i  ( alert_rx[1:1] ),
+      .alert_tx_o  ( alert_tx[2+:2] ),
+      .alert_rx_i  ( alert_rx[4+:4] ),
       .clk_i (clkmgr_clocks.clk_main_hmac),
       .rst_ni (rstmgr_resets.rst_sys_n)
   );
@@ -750,6 +750,8 @@ module top_earlgrey #(
       .rst_ni (rstmgr_resets.rst_sys_n)
   );
 
+  import pwrmgr_pkg::*;
+
   pwrmgr u_pwrmgr (
       .tl_i (tl_pwrmgr_d_h2d),
       .tl_o (tl_pwrmgr_d_d2h),
@@ -759,16 +761,16 @@ module top_earlgrey #(
 
       // Inter-module signals
       .pwr_ast_o(),
-      .pwr_ast_i(pwrmgr_pkg::PWR_AST_RSP_DEFAULT),
+      .pwr_ast_i(PWR_AST_RSP_DEFAULT),
       .pwr_rst_o(pwrmgr_pwr_rst_req),
       .pwr_rst_i(pwrmgr_pwr_rst_rsp),
       .pwr_clk_o(pwrmgr_pwr_clk_req),
       .pwr_clk_i(pwrmgr_pwr_clk_rsp),
       .pwr_otp_o(),
-      .pwr_otp_i(pwrmgr_pkg::PWR_OTP_RSP_DEFAULT),
+      .pwr_otp_i(PWR_OTP_RSP_DEFAULT),
       .pwr_lc_o(),
-      .pwr_lc_i(pwrmgr_pkg::PWR_LC_RSP_DEFAULT),
-      .pwr_flash_i(pwrmgr_pkg::PWR_FLASH_DEFAULT),
+      .pwr_lc_i(PWR_LC_RSP_DEFAULT),
+      .pwr_flash_i(PWR_FLASH_DEFAULT),
       .pwr_cpu_i(pwrmgr_pwr_cpu),
       .wakeups_i(pwrmgr_wakeups),
       .rstreqs_i('0),
@@ -778,6 +780,8 @@ module top_earlgrey #(
       .rst_slow_ni (rstmgr_resets.rst_por_aon_n)
   );
 
+  import rstmgr_pkg::*;
+
   rstmgr u_rstmgr (
       .tl_i (tl_rstmgr_d_h2d),
       .tl_o (tl_rstmgr_d_d2h),
@@ -786,9 +790,9 @@ module top_earlgrey #(
       .pwr_i(pwrmgr_pwr_rst_req),
       .pwr_o(pwrmgr_pwr_rst_rsp),
       .resets_o(rstmgr_resets),
-      .ast_i(rstmgr_pkg::RSTMGR_AST_DEFAULT),
+      .ast_i(RSTMGR_AST_DEFAULT),
       .cpu_i(rstmgr_cpu),
-      .peri_i(rstmgr_pkg::RSTMGR_PERI_DEFAULT),
+      .peri_i(RSTMGR_PERI_DEFAULT),
       .scanmode_i   (scanmode_i),
       .scan_rst_ni  (scan_rst_ni),
       .clk_i (clkmgr_clocks.clk_io_powerup),
@@ -800,6 +804,8 @@ module top_earlgrey #(
       .rst_ni (rst_ni)
   );
 
+  import clkmgr_pkg::*;
+
   clkmgr u_clkmgr (
       .tl_i (tl_clkmgr_d_h2d),
       .tl_o (tl_clkmgr_d_d2h),
@@ -812,7 +818,7 @@ module top_earlgrey #(
       .clk_aon_i(clkmgr_clk_aon),
       .pwr_i(pwrmgr_pwr_clk_req),
       .pwr_o(pwrmgr_pwr_clk_rsp),
-      .dft_i(clkmgr_pkg::CLK_DFT_DEFAULT),
+      .dft_i(CLK_DFT_DEFAULT),
       .status_i(clkmgr_status),
       .clk_i (clkmgr_clocks.clk_io_powerup),
       .rst_ni (rstmgr_resets.rst_por_io_n),
@@ -904,8 +910,8 @@ module top_earlgrey #(
       // [2]: imem_uncorrectable
       // [3]: dmem_uncorrectable
       // [4]: reg_uncorrectable
-      .alert_tx_o  ( alert_tx[4:2] ),
-      .alert_rx_i  ( alert_rx[4:2] ),
+      .alert_tx_o  ( alert_tx[4+:6] ),
+      .alert_rx_i  ( alert_rx[8+:12] ),
 
       // Inter-module signals
       .idle_o(),
diff --git a/hw/top_earlgrey/top_earlgrey_nexysvideo.core b/hw/top_earlgrey/top_earlgrey_nexysvideo.core
index 8d6cf89b6..1683f0693 100644
--- a/hw/top_earlgrey/top_earlgrey_nexysvideo.core
+++ b/hw/top_earlgrey/top_earlgrey_nexysvideo.core
@@ -56,7 +56,7 @@ targets:
     filesets:
       - files_rtl_nexysvideo
       - files_constraints
-      - files_tcl
+      #- files_tcl
     toplevel: top_earlgrey_nexysvideo
     parameters:
       - BootRomInitFile
@@ -64,6 +64,15 @@ targets:
     tools:
       vivado:
         part: "xc7a200tsbg484-1" # Nexys Video
+        synth: "yosys"
+        yosys_synth_options: ['-iopad', '-family xc7', "frontend=surelog"]
+        yosys_read_options: []
+        surelog_options: ['--disable-feature=parametersubstitution', '-DSYNTHESIS']
+      yosys:
+        arch: "xilinx"
+        yosys_synth_options: ['-iopad', '-family xc7', "frontend=surelog"]
+        yosys_read_options: []
+        surelog_options: ['--disable-feature=parametersubstitution', '-DSYNTHESIS']
 
   lint:
     <<: *default_target
