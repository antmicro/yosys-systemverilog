#!/usr/bin/env python3
"""Executes FuseSoC for each of the cores in dependency graph and stores results
It uses a DOT file as input (with a dependecy graph generated by FuseSoC),
and writes results to 'result.txt' and 'graph.dot'

Usage:
    ./iterate_cores.py ./dependency_graph.dot
"""
from subprocess import run
from enum import Enum
import argparse
import pygraphviz as pgv
import re
import networkx as nx

parser = argparse.ArgumentParser()
parser.add_argument('dot', help='Dot file with dependency graph generated using "fusesoc dep graph â€¦"')
parser.add_argument('--skiplist', help='file with a list of Cores to skip')
parser.add_argument('--passlist', help='file with a list of Cores expected to pass')
args = parser.parse_args()

dot_graph = pgv.AGraph(args.dot)
graph = nx.DiGraph(dot_graph)

skiplist = ''
if args.skiplist:
    with open(args.skiplist) as f:
        skiplist = f.read()

passlist = ''
if args.passlist:
    with open(args.passlist) as f:
        passlist = f.read()

class Status(Enum):
    FAILED = 1
    PASSED = 2
    UNKNOWN = 3
    SKIPPED = 4
    DEPENDENCY_FAILED = 5

nx.set_node_attributes(graph, {node: Status.UNKNOWN for node in graph}, 'status')
root = [node for node, degree in graph.in_degree() if degree == 0][0]
nodes = list(nx.topological_sort(graph))

def process_node(graph, node):
    status = nx.get_node_attributes(graph, 'status')[node]
    if status == Status.UNKNOWN:
        cmd = ['fusesoc', '--cores-root=.', 'run', '--flag=fileset_ip', '--target=default', '--build', '--tool=yosys', node]
        print('running: ' + ' '.join(cmd))
        fuse = run(cmd, shell=False, capture_output=False)
        if fuse.returncode == 0:
            nx.set_node_attributes(graph, {node: Status.PASSED}, 'status')
        else:
            nx.set_node_attributes(graph, {node: Status.FAILED}, 'status')

for node in nodes:
    # If the node belongs to the skiplist, set status and continue
    if re.search("^" + node, skiplist, re.MULTILINE):
        nx.set_node_attributes(graph, {node: Status.SKIPPED}, 'status')
        continue

    if not nx.get_node_attributes(graph, 'status')[node] == Status.UNKNOWN:
        continue

    process_node(graph, node)
    if nx.get_node_attributes(graph, 'status')[node] == Status.PASSED:
        children_names = list(graph[node])
        for child in children_names:
            nx.set_node_attributes(graph, {child: Status.SKIPPED}, 'status')

# write markdown table with results
with open('result.txt', 'w') as f:
    f.write('| Name | Result |\n')
    f.write('|------|--------|\n')

    status_labels = {
        Status.PASSED: ':heavy_check_mark: PASSED',
        Status.SKIPPED: ':heavy_minus_sign: SKIPPED',
        Status.FAILED: ':x: FAILED',
        Status.DEPENDENCY_FAILED: ':x: DEPENDENCY_FAILED',
    }
    for node in graph:
        status = nx.get_node_attributes(graph, 'status')[node]
        status_label = status_labels.get(status, status.name)
        f.write(f'| {node} | {status_label} |\n')

    passed = {node for node, status in nx.get_node_attributes(graph, 'status').items() if status == Status.PASSED}
    failed = {node for node, status in nx.get_node_attributes(graph, 'status').items() if status == Status.FAILED}
    skipped = {node for node, status in nx.get_node_attributes(graph, 'status').items() if status == Status.SKIPPED}
    dependecy_failed = {node for node, status in nx.get_node_attributes(graph, 'status').items() if status == Status.DEPENDENCY_FAILED}

    f.write('\n')
    f.write('|  |  |\n')
    f.write('|--|--|\n')
    f.write(f'| PASSED | {len(passed)} |\n')
    f.write(f'| FAILED | {len(failed)} |\n')
    f.write(f'| SKIPPED | {len(skipped)} |\n')
    f.write(f'| DEPENDENCY_FAILED | {len(dependecy_failed)} |\n')
    f.write('\n')

    failed_deps = {str(fail): list(graph.predecessors(fail)) for fail in failed} 
    f.write('|Failed node| Used by | |\n')
    f.write('|--|--|--|\n')
    # sort failed nodes by the number of nodes that depend on that node, descending
    # limit the result to 10 entries
    result_limit = 10
    for dependency, predecessors in sorted(failed_deps.items(), key=lambda item: len(item[1]), reverse=True)[:result_limit]:
        pred = ', '.join(predecessors)
        f.write(f'|{dependency}|{pred}|{len(predecessors)}|\n')
    f.write('\n')
    f.write(f'(limited to {result_limit} results)\n')

    # cores that previously didn't pass for whatever reason, and now passed
    new_passes = {node for node in passed if not re.search("^" + node, passlist, re.MULTILINE)}
    # cores that previously passed and now don't
    new_fails = {node for node in failed if re.search("^" + node, passlist, re.MULTILINE)}

    if new_passes:
        f.write('| Unexpected pass for cores: |\n')
        f.write('|----|\n')
        for node in new_passes:
            f.write(f'|{node}|\n')
        f.write('\n')

    if new_fails:
        f.write('| Unexpected fail for cores: |\n')
        f.write('|----|\n')
        for node in new_fails:
            f.write(f'|{node}|\n')
        f.write('\n')


# set node colors and status attributes
for node in graph:
    status = nx.get_node_attributes(graph, 'status')[node]
    if status == Status.FAILED:
        nx.set_node_attributes(graph, {node: 'red'}, 'fillcolor')
        nx.set_node_attributes(graph, {node: 'filled'}, 'style')
    if status == Status.PASSED:
        nx.set_node_attributes(graph, {node: 'lightblue'}, 'fillcolor')
        nx.set_node_attributes(graph, {node: 'filled'}, 'style')

    nx.set_node_attributes(graph, {node: status.name}, 'status')

graph.graph['graph']={'rankdir':'LR'}
nx.drawing.nx_agraph.write_dot(graph, 'graph.dot')
